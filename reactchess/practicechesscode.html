      case 'k':
        return Math.abs(rowDiff) <= 1 && Math.abs(colDiff) <= 1;

      default:
        return false;
    }
  }

  function isPathBlocked(startRow, startCol, targetRow, targetCol) {
    const rowStep = targetRow > startRow ? 1 : targetRow < startRow ? -1 : 0;
    const colStep = targetCol > startCol ? 1 : targetCol < startCol ? -1 : 0;
    let row = startRow + rowStep;
    let col = startCol + colStep;
    while (row !== targetRow || col !== targetCol) {
      if (game[row][col] !== '') return true;
      row += rowStep;
      col += colStep;
    }
    return false;
  }

  // Function for the CPU (Black) to make a move
  function cpuMove() {
    const newGame = game.map(row => row.slice());
    const availableMoves = [];

    // Find all possible moves for the CPU
    for (let row = 0; row < game.length; row++) {
      for (let col = 0; col < game[row].length; col++) {
        const piece = game[row][col];
        if (piece !== '' && isPlayerPiece(piece, false)) { // CPU's pieces (Black)
          for (let targetRow = 0; targetRow < game.length; targetRow++) {
            for (let targetCol = 0; targetCol < game[targetRow].length; targetCol++) {
              if (isValidMove(piece, row, col, targetRow, targetCol, newGame)) {
                availableMoves.push({ piece, startRow: row, startCol: col, targetRow, targetCol });
              }
            }
          }
        }
      }
    }

    if (availableMoves.length === 0) {
      setGameOver(true);
      announceEvent("Game Over! White wins.");
      return;
    }

    // Randomly choose one of the available moves
    const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
    newGame[randomMove.targetRow][randomMove.targetCol] = randomMove.piece;
    newGame[randomMove.startRow][randomMove.startCol] = '';
    setGame(newGame);
    setIsWhiteTurn(true);

    // Check if CPU captures the White King
    if (randomMove.piece.toLowerCase() === 'k') {
      setGameOver(true);
      announceEvent("Game Over! Black wins by capturing the King.");
    } else {
      announceTurn("White"); // Announce White's turn
    }
  }

  return (
    <div>
      <div className="turn-info">
        {gameOver ? "Game Over!" : `Current Turn: ${isWhiteTurn ? 'White' : 'Black (CPU)'}`}
      </div>
      <div className="button-container">
        <button onClick={startRestartGame}>{gameOver ? 'Restart Game' : 'Start/Restart Game'}</button>
        <button onClick={toggleTTS}>{isTTSEnabled ? 'Disable TTS' : 'Enable TTS'}</button> {/* TTS toggle button */}
      </div>
      <div className="board-container">
        <Board game={game} selectedSquare={selectedSquare} onClick={handleClick} />
      </div>
    </div>
  );
}

function Board({ game, selectedSquare, onClick }) {
  return (
    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(8, 60px)', gridGap: 0 }}>
      {game.map((row, rowIndex) =>
        row.map((square, colIndex) => (
          <Square
            key={`${rowIndex}-${colIndex}`}
            piece={square}
            selected={selectedSquare && selectedSquare[0] === rowIndex && selectedSquare[1] === colIndex}
            onClick={() => onClick(rowIndex, colIndex)}
          />
        ))
      )}
    </div>
  );
}

function Square({ piece, selected, onClick }) {
  const backgroundColor = selected ? '#a9d7ff' : (piece !== '' ? '#f0d9b5' : '#b58863');
  return (
    <div
      onClick={onClick}
      style={{
        width: '60px',
        height: '60px',
        backgroundColor,
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        cursor: 'pointer',
        border: '1px solid #000',
      }}
    >
      {piece && <img src={pieceImages[piece]} alt={piece} style={{ width: '50px', height: '50px' }} />}
    </div>
  );
}

ReactDOM.render(<Game />, document.getElementById('root'));
